<html>
<head>
<style>
body
{
	background-color: #000000;
	margin: 0px;
	overflow: hidden;
}
</style>
<script type="text/javascript" src="scripts/util/Requests.js"></script>

<script type="text/javascript">
		 	var testlogger;
		 	DependencyManager.register("Arrays", 						"util/Arrays.js");
		 	DependencyManager.register("Events", 						"util/Events.js");
		 	DependencyManager.register("Logging", 						"util/Logging.js");
		 	DependencyManager.register("Requests", 						"util/Requests.js");
		 	DependencyManager.register("DateFormat", 					"lib/date.format.js");
		 	DependencyManager.register("Raphael", 						"lib/raphael-min.js");
		 	DependencyManager.register("Stats", 						"lib/Stats.js");
		 	DependencyManager.register("Three", 						"lib/Three.js");
		 	DependencyManager.register("Detector", 						"lib/Detector.js");
		 	DependencyManager.register("RequestAnimationFrame", 		"lib/RequestAnimationFrame.js");
		 	DependencyManager.afterLoading(function(){
		 		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		 		init();
		 		render();
		 	});
		 	
			var container, stats;
			var camera, scene, renderer;
			var particles;
			var materials;
			var dragging;
			var zoom = 1;
			var dist = 1000;
			var phi = Math.PI/4;
			var theta = Math.PI/2;
			var lastX, lastY, lastPhi, lastTheta;

			function init() {
				
				testlogger = new Logging.Logger("test", Logging.LEVEL_DEBUG);

				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				container.appendChild( renderer.domElement );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				
				camera = new THREE.Camera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				/*
				camera.position.x = dist*zoom*Math.sin(theta)*Math.cos(phi);
				camera.position.y = dist*zoom*Math.sin(theta)*Math.sin(phi);
				camera.position.z = dist*zoom*Math.cos(theta);
				*/
				camera.position.x = dist*zoom;
				camera.position.y = 0;
				camera.position.z = 0;
				camera.target.position.x = 0;
				camera.target.position.y = 0;
				camera.target.position.z = 0;

				onWindowResize();
				
				scene = new THREE.Scene();
				
				for(x in scene)
					testlogger.debug(x);
				
				particles = [];
				materials = [];

				materials[0] = new THREE.ParticleBasicMaterial( { map: ImageUtils.loadTexture( 'nova_particle.png' ), blending: THREE.AdditiveBlending } );

				for ( var i = 0; i < 1000; i ++ )
				{
					particles[ i ] = particle = new THREE.Particle( materials[0] );
					particle.position.x = Math.random() - 0.5;
					particle.position.y = Math.random() - 0.5;
					particle.position.z = Math.random() - 0.5;
					particle.position.normalize();
					particle.position.multiplyScalar( Math.random() * 1000 + 100 );
					particle.scale.x = particle.scale.y = Math.random() * 0.5;
					scene.addObject( particle );
				}
				
				// Cube
				var materials2 = [];
				for ( var i = 0; i < 6; i ++ )
					materials2.push( [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ] );
				cube = new THREE.Mesh( new Cube( 200, 200, 200, 1, 1, 1, materials2 ), new THREE.MeshFaceMaterial() );
				cube.overdraw = true;
				scene.addObject( cube );
				
				document.addEventListener('mousedown', mouseDown, false);
				document.addEventListener('mousemove', mouseMove, false);
				document.addEventListener('mouseup', mouseUp, false);
				document.addEventListener('mousewheel', mouseWheel, false);
				document.addEventListener('DOMMouseScroll', mouseWheel, false);
				window.addEventListener('resize', onWindowResize, false);
			}
			
			function onWindowResize( event )
			{
				var width = window.innerWidth, height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				renderer.domElement.style.width = window.innerWidth + 'px';
				renderer.domElement.style.height = window.innerHeight + 'px';
			}

			function mouseDown(event)
			{
				dragging = true;
			    var coords = clickCoordsWithinElement(event);
				lastX = coords.x;
				lastY = coords.y;
				lastPhi = phi;
				lastTheta = theta;				
			}

			function mouseUp()
			{
				dragging = false;
			}
			
			function mouseMove(event)
			{
				if (dragging)
				{							
					phi = ( event.clientX - lastX ) * 10 * 0.0003 + lastPhi;
					theta = ( event.clientY - lastY ) * 10 * 0.0003 + lastTheta;
				}
			}
			
			function mouseWheel(event)
			{
			    var delta = 0;
			    if (!event) event = window.event;
			    if (event.wheelDelta) {
			        delta = event.wheelDelta / 120;
			        if (window.opera) delta = -delta;
			    } else if (event.detail) {
			        delta = -event.detail / 3;
			    }
			    if (delta) {
			        if (delta < 0) {
			        	zoom *= 1.1;
			        } else {
			        	zoom /= 1.1;
			        }
			    }
			    testlogger.debug(zoom);
			    if (event.preventDefault)
			        event.preventDefault();
			    event.returnValue = false;
			}
			
			function clickCoordsWithinElement(event)
			{
				var coords = {
					x : 0,
					y : 0
				};
				if (!event)
				{
					event = window.event;
					coords.x = event.x;
					coords.y = event.y;
				}
				else
				{
					var element = event.target;
					var totalOffsetLeft = 0;
					var totalOffsetTop = 0;

					while (element.offsetParent)
					{
						totalOffsetLeft += element.offsetLeft;
						totalOffsetTop += element.offsetTop;
						element = element.offsetParent;
					}
					coords.x = event.pageX - totalOffsetLeft;
					coords.y = event.pageY - totalOffsetTop;
				}
				return coords;
			}

			function render()
			{
				camera.position.x = dist*zoom;
				/*
				camera.position.x = dist*zoom*Math.sin(theta)*Math.cos(phi);
				camera.position.y = dist*zoom*Math.sin(theta)*Math.sin(phi);
				camera.position.z = dist*zoom*Math.cos(theta);
				*/
				scene.rotation.x = phi;
				scene.rotation.y = theta;
				renderer.render( scene, camera );
				stats.update();
				setTimeout(render, 1000/60);
			}
		</script>
</head>
<body onload="DependencyManager.registrationDone();">
	<div id="container"></div>
</body>
</html>