<html>
<head>
<meta charset="utf-8">
<style type="text/css">
body {
	margin: 0px;
}
</style>
<script type="text/javascript" src="scripts/util/Requests.js"></script>

<script type="text/javascript">
	var testlogger;
	DependencyManager.register("Arrays", 					"util/Arrays.js");
	DependencyManager.register("Events", 					"util/Events.js");
	DependencyManager.register("Logging", 					"util/Logging.js");
	DependencyManager.register("Requests", 					"util/Requests.js");
	DependencyManager.register("DateFormat", 				"lib/date.format.js");
	DependencyManager.register("Raphael", 					"lib/raphael-min.js");
	DependencyManager.register("Stats", 					"lib/Stats.js");
	DependencyManager.register("SceneJS", 					"scenejs/scenejs.min.js");
	DependencyManager.register("SceneJS-Query-Nodepos",		"scenejs/utils/query/scenejs-query-node-pos.js", false, ["SceneJS"]);
	
	DependencyManager.afterLoading(init0);

	var yaw = 30;
	var pitch = -30;
	var lastX;
	var lastY;
	var dragging = false;

	var canvas;
	var stats;

	var c = new Array();

	/* Render loop until error or reset
	 * (which IDE does whenever you hit that run again button)
	 */
	var pInterval;
	
	var query, query2;
	
	var xstart = 0;
	var ystart = 10.0;
	var zstart = -55;
	var zoom = 1;

	function init0()
	{
		testlogger = new Logging.Logger("test", Logging.LEVEL_DEBUG);

		SceneJS.createNode({
			type : "scene",
			id : "the-scene",
			canvasId : "theCanvas",
			loggingElementId : "theLoggingDiv",

			nodes : [ {
				type : "lookAt",
				id : "lookAt",
				eye : {
					x : xstart,
					y : ystart,
					z : zstart
				},
				look : {
					y : 1.0
				},
				up : {
					y : 1.0
				},

				nodes : [ {
					type : "camera",
					id: "camera",
					optics : {
						type : "perspective",
						fovy : 25.0,
						aspect : 1.47,
						near : zoom,
						far : 3000.0
					},

					nodes : [ {
						type : "light",
						mode : "dir",
						color : {
							r : 0.5,
							g : 0.5,
							b : 0.5
						},
						diffuse : true,
						specular : true,
						dir : {
							x : 1.0,
							y : 1.0,
							z : -1.0
						}
					}, {
						type : "light",
						mode : "dir",
						color : {
							r : 0.7,
							g : 0.7,
							b : 0.7
						},
						diffuse : true,
						specular : true,
						dir : {
							x : 0.0,
							y : 1.0,
							z : -1.0
						}
					}, {
						type : "light",
						mode : "dir",
						color : {
							r : 0.8,
							g : 0.8,
							b : 0.8
						},
						diffuse : true,
						specular : true,
						dir : {
							x : -1.0,
							y : 0.0,
							z : -1.0
						}
					},

					/* Next, modelling transforms to orient our geometry
					 * by a given angles. The rotate nodes have IDs that we'll locate them with below.
					 */
					{
						type : "rotate",
						id : "pitch",
						angle : 0.0,
						x : 1.0,

						nodes : [ {
							type : "rotate",
							id : "yaw",
							angle : 0.0,
							y : 1.0,

							nodes : [ {
								type : "translate",
								x : 5,
								y : 5,
								z : 5,
								nodes : [ {
									type : "node",
									id : "corner0",

									nodes : [ {
										type : "sphere",
										id: "sphere0",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},  {
								type : "translate",
								x : 5,
								y : 5,
								z : -5,
								nodes : [ {
									type : "node",
									id : "corner1",

									nodes : [ {
										type : "sphere",
										id: "sphere1",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},  {
								type : "translate",
								x : 5,
								y : -5,
								z : 5,
								nodes : [ {
									type : "node",
									id : "corner2",

									nodes : [ {
										type : "sphere",
										id: "sphere2",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},  {
								type : "translate",
								x : 5,
								y : -5,
								z : -5,
								nodes : [ {
									type : "node",
									id : "corner3",

									nodes : [ {
										type : "sphere",
										id: "sphere3",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},{
								type : "translate",
								x : -5,
								y : 5,
								z : 5,
								nodes : [ {
									type : "node",
									id : "corner4",

									nodes : [ {
										type : "sphere",
										id: "sphere4",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							}, {
								type : "translate",
								x : -5,
								y : 5,
								z : -5,
								nodes : [ {
									type : "node",
									id : "corner5",

									nodes : [ {
										type : "sphere",
										id: "sphere5",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},{
								type : "translate",
								x : -5,
								y : -5,
								z : 5,
								nodes : [ {
									type : "node",
									id : "corner6",

									nodes : [ {
										type : "sphere",
										id: "sphere6",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},{
								type : "translate",
								x : -5,
								y : -5,
								z : -5,
								nodes : [ {
									type : "node",
									id : "corner7",

									nodes : [ {
										type : "sphere",
										id: "sphere7",
										slices : 6,
										rings : 12,
										radius : 1
									} ]
								} ]
							},{
								type : "material",
								baseColor : {
									r : 1.0,
									g : 1.0,
									b : 1.0
								},
								specularColor : {
									r : 0.9,
									g : 0.9,
									b : 0.9
								},
								specular : 0.9,
								shine : 6.0,

								nodes : [ {
									type : "texture",
									layers : [ {
										uri : "BrickWall.jpg",
										minFilter : "linear",
										magFilter : "linear",
										wrapS : "repeat",
										wrapT : "repeat",
										isDepth : false,
										depthMode : "luminance",
										depthCompareMode : "compareRToTexture",
										depthCompareFunc : "lequal",
										flipY : false,
										width : 1,
										height : 1,
										internalFormat : "lequal",
										sourceFormat : "alpha",
										sourceType : "unsignedByte",
										applyTo : "baseColor",
										blendMode : "multiply",

										/* Texture rotation angle in degrees
										 */
										rotate : 0.0,

										/* Texture translation offset
										 */
										translate : {
											x : 0,
											y : 0
										},

										/* Texture scale factors
										 */
										scale : {
											x : .1,
											y : .05
										}
									} ],

									nodes : [

									/* Aha, here you are, glad you made it!
									 *
									 * Here is the geometry node which defines our
									 * custom object, a simple cube.
									 */
									{

										type : "geometry",
										id : "cube",

										/* Optional resource name, must be unique among all
										 * geometries - if another geometry has already
										 * been defined with this resource type, then that
										 * geometry will be instanced here in place of
										 * this one, and this geometry definition will be
										 * ignored. This supports dynamic instancing,
										 * where we may reuse the same geometry in
										 * many places to save memory.
										 */
										resource : "my-geometry",

										/* The primitive type - allowed values are
										 * "points", "lines", "line-loop", "line-strip",
										 * "triangles", "triangle-strip" and "triangle-fan".
										 *
										 * Try setting this config to these different
										 * types, it's quite freaky.
										 *
										 * See the OpenGL/WebGL specification docs for
										 * how the coordinate arrays are supposed to be laid out
										 * for them.
										 */
										primitive : "triangles",

										/* The vertices - eight for our cube, each
										 * one spaining three array elements for X,Y and Z
										 */
										positions : [

										/* v0-v1-v2-v3 front
										 */
										5, 5, 5, -5, 5, 5, -5, -5, 5, 5, -5, 5,

										/* v0-v3-v4-v5 right
										 */
										5, 5, 5, 5, -5, 5, 5, -5, -5, 5, 5, -5,

										/* v0-v5-v6-v1 top
										 */
										5, 5, 5, 5, 5, -5, -5, 5, -5, -5, 5, 5,

										/* v1-v6-v7-v2 left
										 */
										-5, 5, 5, -5, 5, -5, -5, -5, -5, -5, -5, 5,

										/* v7-v4-v3-v2 bottom
										 */
										-5, -5, -5, 5, -5, -5, 5, -5, 5, -5, -5, 5,

										/* v4-v7-v6-v5 back
										 */
										5, -5, -5, -5, -5, -5, -5, 5, -5, 5, 5, -5 ],

										/* Normal vectors, one for each vertex
										 */
										normals : [

										/* v0-v1-v2-v3 front
										 */
										0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,

										/* v0-v3-v4-v5 right
										 */
										-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,

										/* v0-v5-v6-v1 top
										 */
										0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,

										/* v1-v6-v7-v2 left
										 */
										1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,

										/* v7-v4-v3-v2 bottom
										 */
										0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,

										/* v4-v7-v6-v5 back
										 */
										0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ],

										/* 2D texture coordinates corresponding to the
										 * 3D positions defined above - eight for our cube, each
										 * one spaining two array elements for X and Y
										 */
										uv : [

										/* v0-v1-v2-v3 front
										 */
										5, 5, 0, 5, 0, 0, 5, 0,

										/* v0-v3-v4-v5 right
										 */
										0, 5, 0, 0, 5, 0, 5, 5,

										/* v0-v5-v6-v1 top
										 */
										5, 0, 5, 5, 0, 5, 0, 0,

										/* v1-v6-v7-v2 left
										 */
										5, 5, 0, 5, 0, 0, 5, 0,

										/* v7-v4-v3-v2 bottom
										 */
										0, 0, 5, 0, 5, 5, 0, 5,

										/* v4-v7-v6-v5 back
										 */
										0, 0, 5, 0, 5, 5, 0, 5 ],

										/* Indices - these organise the
										 * positions and uv texture coordinates
										 * into geometric primitives in accordance
										 * with the "primitive" parameter,
										 * in this case a set of three indices
										 * for each triangle.
										 *
										 * Note that each triangle is specified
										 * in counter-clockwise winding order.
										 *
										 * You can specify them in clockwise
										 * order if you configure the SceneJS.renderer
										 * node's frontFace property as "cw", instead of
										 * the default "ccw".
										 */
										indices : [

										/* Front
										 */
										0, 1, 2, 0, 2, 3,

										/* Right
										 */
										4, 5, 6, 4, 6, 7,

										/* Top
										 */
										8, 9, 10, 8, 10, 11,

										/* Left
										 */
										12, 13, 14, 12, 14, 15,

										/* Bottom
										 */
										16, 17, 18, 16, 18, 19,

										/* Back
										 */
										20, 21, 22, 20, 22, 23 ]
									} ]
								} ]
							} ]
						} ]
					} ]
				} ]
			} ]
		});
		
		var amountX = 2;
		var amountY = 2;
		var gridX = 20;
		var gridY = 20;
		for(x = -amountX/2; x <= amountX/2; x++)
		{
			for(y = -amountY/2; y <= amountY/2; y++)
			{
				if(x == 0 && y == 0)
					continue;
				SceneJS.withNode("camera").add("node", {
					type : "translate",
					x : x*gridX,
					y : y*gridY,
					z : 0,
					nodes : [ {
		                type: "instance",
		                target: "pitch"
		            } ]
				});
			}
		}
		canvas = document.getElementById("theCanvas");
		document.addEventListener('mousedown', mouseDown, true);
		document.addEventListener('mousemove', mouseMove, true);
		document.addEventListener('mouseup', mouseUp, true);
		document.addEventListener('mousewheel', mouseWheel, true);
		document.addEventListener('DOMMouseScroll', mouseWheel, true);

		//canvas.addEventListener('mousedown', mouseDown, false);

		SceneJS.bind("error", function()
		{
			window.clearInterval(pInterval);
		});

		SceneJS.bind("reset", function()
		{
			window.clearInterval(pInterval);
		});
		
		query = new SceneJS.utils.query.QueryNodePos({
		    canvasWidth : canvas.clientWidth,
		    canvasHeight : canvas.clientHeight
		});
		
		paper = Raphael(0,0,800,600);
		
		for(var i = 0; i < 8; i++)
		{
			c[i] = paper.circle(50*i, 50*i, 20).attr({stroke: "#F00", "stroke-width": 5});
			c[i].moveTo = function(x,y) { this.attr({cx: x, cy: y}) };
			c[i].hide();
			
			SceneJS.withNode("corner" + i).bind("picked", (function(i) {
				return function(event)
				{
					if(c[i].node.style.display == "none")
						c[i].show();
					else
						c[i].hide();
				}
			})(i) );	
		}
		
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		document.body.appendChild( stats.domElement );
		
		pInterval = window.setInterval("window.render()", 10);
	}

	function mouseDown(event)
	{
		lastX = event.clientX;
		lastY = event.clientY;
		dragging = true;
	    var coords = clickCoordsWithinElement(event);
	    SceneJS.withNode("the-scene").pick(coords.x, coords.y);
	}

	function mouseUp()
	{
		dragging = false;
	}

	/* On a mouse drag, we'll re-render the scene, passing in
	 * incremented angles in each time.
	 */
	function mouseMove(event)
	{
		if (dragging)
		{
			yaw += (event.clientX - lastX) * 0.5;
			pitch += (event.clientY - lastY) * -0.5;

			lastX = event.clientX;
			lastY = event.clientY;
		}
	}
	
	function mouseWheel(event) {
	    var delta = 0;
	    if (!event) event = window.event;
	    if (event.wheelDelta) {
	        delta = event.wheelDelta / 120;
	        if (window.opera) delta = -delta;
	    } else if (event.detail) {
	        delta = -event.detail / 3;
	    }
	    if (delta) {
	        if (delta < 0) {
	        	zoom += 0.1;
	        } else {
	        	zoom -= 0.1;
	        }
	    }
	    testlogger.debug(zoom);
	    if (event.preventDefault)
	        event.preventDefault();
	    event.returnValue = false;
	}
	
	function clickCoordsWithinElement(event)
	{
		var coords = {
			x : 0,
			y : 0
		};
		if (!event)
		{
			event = window.event;
			coords.x = event.x;
			coords.y = event.y;
		}
		else
		{
			var element = event.target;
			var totalOffsetLeft = 0;
			var totalOffsetTop = 0;

			while (element.offsetParent)
			{
				totalOffsetLeft += element.offsetLeft;
				totalOffsetTop += element.offsetTop;
				element = element.offsetParent;
			}
			coords.x = event.pageX - totalOffsetLeft;
			coords.y = event.pageY - totalOffsetTop;
		}
		return coords;
	}

	window.render = function()
	{
		SceneJS.withNode("pitch").set("angle", pitch);
		SceneJS.withNode("yaw").set("angle", yaw);
		
		SceneJS.withNode("lookAt").get("eye").x = zoom*xstart;
		SceneJS.withNode("lookAt").get("eye").y = zoom*ystart;
		SceneJS.withNode("lookAt").get("eye").z = zoom*zstart;
		SceneJS.withNode("lookAt").set("eye", {x: zoom*xstart, y: zoom*ystart, z: zoom*zstart });
		SceneJS.withNode("the-scene").render();
		
		
		for(var i = 0; i < 8; i++)
		{
			query.execute({
		        nodeId: "sphere" + i
		    });
			var results = query.getResults();
			
			//for(x in results.canvasPos)
			//	testlogger.debug(x);
			c[i].moveTo(results.canvasPos.x,results.canvasPos.y);
			
			//var scale = 1/Math.pow(zoom, 1.6);
			//c[i].scale(scale, scale);
		}
		
		
		stats.update();
	};
</script>
</head>
<body onload="DependencyManager.registrationDone();">
	<canvas id="theCanvas" width="800" height="600" style="zIndex: 1000;"></canvas>
</body>
</html>