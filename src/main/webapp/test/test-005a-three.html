<html>
<head>
<meta charset="utf-8">
<style type="text/css">
body {
	color: #808080;
	font-family: Monospace;
	font-size: 13px;
	text-align: center;
	background-color: #fff;
	margin: 0px;
	overflow: hidden;
}

#info {
	position: absolute;
	top: 0px;
	width: 100%;
	padding: 5px;
}

a {
	color: #0080ff;
}
</style>
<script type="text/javascript" src="scripts/util/Requests.js"></script>

<script type="text/javascript">
	var testlogger;
	DependencyManager.register("Arrays", "util/Arrays.js");
	DependencyManager.register("Events", "util/Events.js");
	DependencyManager.register("Logging", "util/Logging.js");
	DependencyManager.register("Requests", "util/Requests.js");
	DependencyManager.register("DateFormat", "lib/date.format.js");
	DependencyManager.register("Raphael", "lib/raphael-min.js");
	DependencyManager.register("Three", "lib/Three.js");
	DependencyManager.register("Stats", "lib/Stats.js");
	DependencyManager.register("Detector", "lib/Detector.js");
	DependencyManager.register("RequestAnimationFrame", "lib/RequestAnimationFrame.js");
	DependencyManager.afterLoading(init0);

	var container, stats;

	var camera, scene, renderer;

	var obj, plane;

	var targetRotation = 0;
	var targetRotationOnMouseDown = 0;

	var mouseX = 0;
	var mouseXOnMouseDown = 0;

	function init0()
	{
		if (!Detector.webgl)
			Detector.addGetWebGLMessage();
		init();
		animate();
	}

	function init()
	{
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		container = document.getElementById("container");
		document.body.appendChild(container);

		var info = document.createElement('div');
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = 'Drag to spin the obj';
		container.appendChild(info);

		camera = new THREE.Camera(70, window.innerWidth / window.innerHeight, 1, 1000);
		camera.position.y = 150;
		camera.position.z = 500;
		camera.target.position.y = 150;

		scene = new THREE.Scene();
		
		var ambient = new THREE.AmbientLight( 0x101010 );
		scene.addLight( ambient );

		directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.x = 1;
		directionalLight.position.y = 1;
		directionalLight.position.z = 2;
		directionalLight.position.normalize();
		scene.addLight( directionalLight );

		pointLight = new THREE.PointLight( 0xffffff );
		pointLight.position.x = 0;
		pointLight.position.y = 0;
		pointLight.position.z = 0;
		scene.addLight( pointLight );
		
		geo = new Sphere(0.5, 36, 18);		
		geo = new Cube(1, 1, 1, 1, 1, 1);		
		if(geo)
		{
			var faceIndices = [ 'a', 'b', 'c', 'd' ];
			for( var i = 0; i < geo.faces.length; i++ ) {			
				f  = geo.faces[ i ];			
				n = ( f instanceof THREE.Face3 ) ? 3 : 4;			
				for( var j = 0; j < n; j++ ) {			
					vertexIndex = f[ faceIndices[ j ] ];			
					
					p = geo.vertices[ vertexIndex ].position;
					
					color = new THREE.Color( 0xffffff );
					color.setHSV( ( p.y + 1 ) / 2, ( p.z + 1 ) / 2, ( p.x + 1 ) / 2 );	
					
					f.vertexColors[ j ] = color;
				}			
			}
			var materials = [
				new THREE.MeshPhongMaterial( { ambient: 0x000000, color: 0xffaa00, specular: 0x555555, shininess: 30 } )
				//new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } ),
				//new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true } )
			];
			obj = new THREE.Mesh( geo, materials  );
		}
		obj.position.y = 150;
		obj.scale.x = obj.scale.y = obj.scale.z = 200;
		obj.overdraw = true;
		scene.addObject(obj);

		// Plane

		plane = new THREE.Mesh(new Plane(200, 200), new THREE.MeshBasicMaterial({
			color : 0xaaaaaa
		}));
		plane.rotation.x = -90 * (Math.PI / 180);
		plane.overdraw = true;
		scene.addObject(plane);

		//renderer = new THREE.CanvasRenderer();
		renderer = new THREE.WebGLRenderer();
		//renderer = new THREE.SVGRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);

		container.appendChild(renderer.domElement);

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild(stats.domElement);

		document.addEventListener('mousedown', onDocumentMouseDown, false);
		document.addEventListener('touchstart', onDocumentTouchStart, false);
		document.addEventListener('touchmove', onDocumentTouchMove, false);
	}

	//

	function onDocumentMouseDown(event)
	{

		event.preventDefault();

		document.addEventListener('mousemove', onDocumentMouseMove, false);
		document.addEventListener('mouseup', onDocumentMouseUp, false);
		document.addEventListener('mouseout', onDocumentMouseOut, false);

		mouseXOnMouseDown = event.clientX - windowHalfX;
		targetRotationOnMouseDown = targetRotation;
	}

	function onDocumentMouseMove(event)
	{

		mouseX = event.clientX - windowHalfX;

		targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
	}

	function onDocumentMouseUp(event)
	{

		document.removeEventListener('mousemove', onDocumentMouseMove, false);
		document.removeEventListener('mouseup', onDocumentMouseUp, false);
		document.removeEventListener('mouseout', onDocumentMouseOut, false);
	}

	function onDocumentMouseOut(event)
	{

		document.removeEventListener('mousemove', onDocumentMouseMove, false);
		document.removeEventListener('mouseup', onDocumentMouseUp, false);
		document.removeEventListener('mouseout', onDocumentMouseOut, false);
	}

	function onDocumentTouchStart(event)
	{

		if (event.touches.length == 1)
		{

			event.preventDefault();

			mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
			targetRotationOnMouseDown = targetRotation;

		}
	}

	function onDocumentTouchMove(event)
	{

		if (event.touches.length == 1)
		{

			event.preventDefault();

			mouseX = event.touches[0].pageX - windowHalfX;
			targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;

		}
	}

	//

	function animate()
	{

		requestAnimationFrame(animate);

		render();
		stats.update();

	}

	function render()
	{

		plane.rotation.z = obj.rotation.y += (targetRotation - obj.rotation.y) * 0.05;
		//camera.target.position.x += (targetRotation - obj.rotation.y) * 0.05;
		renderer.render(scene, camera);

	}
</script>
</head>
<body onload="DependencyManager.registrationDone();">
	<div id="container"></div>
</body>
</html>